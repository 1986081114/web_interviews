diff算法：
    react需要同时维护两个dom树结构，一个表示当前的dom结构，另一个保存react状态变更将要重新渲染的虚拟dom。
    react通过比肩这两棵树，决定是否修改dom结构， 以及如何修改，这种算法叫做diff。

    本来diff算法有一些通用的解决方案，就是生成一个树转换成另一棵树的最小操作数， 复杂度是n3.
    但是react在假设条件下改善了以上算法变成o（n）：
      0.虚拟dom只对同一层级元素对比
      1.两个不同类型的元素会产生出不同的树，
      2.开发者可以通过key 来按时哪些元素在不同的渲染下保持稳定。

    维护虚拟dom和diff计算量， 简化了dom操作， 和mvvm变更整个dom数相比， 确实节省了不少时间。
    但是和原生的js的开发模式相比， 还是直接操作dom更快，

diff算法过程：
   diff的过程就是调用名为patch的函数，比较新旧节点，一边比较一边给真实的DOM打补丁
   dif算法会对新旧两棵树做深度优先遍历，然后给每个节点生成一个唯一的标志。
   在遍历的过程中， 对同一级别的元素在新旧两个树上做比较。如果有差异就记录到一个对象中。。

   可能存在的差异：
      不同类型的元素： 该节点以及该节点的子节点会被销毁，创建新的节点。
      同类型的元素：
        react会保留当前dom节点和子节点， 更新有改变的属性。
       节点替换：节点改变了，例如将上面的 div 换成 h1;
       顺序互换：移动、删除、新增子节点，例如上面 div 的子节点，把 p 和 ul 顺序互换；
       属性更改：修改了节点的属性，例如把上面 li 的 class 样式类删除；
       文本改变：改变文本节点的文本内容，例如将上面 p 节点的文本内容更改为 “Real Dom”；

    最后返回一盒patch对象用来实际的dom更新，


    在key中使用index问题：
       1.若对数据逆序添加， 等，会产生没有必要的dom更新
       2.如果结构中还包含输入dom，会产生dom更新界面有问题，

    


    

        

       