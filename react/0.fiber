fiber:
  主要目的： 更新可以中断，实现异步可终端更新。
            实现任务优先级， 可以让高优先级的任务先执行，

   
由于es6有了generator，可以中断函数的停止，为什么不用这个？
   1.使用generator 需要将所有的代码包装成generator 的格式工作量很大
   2. 由于generator内部是有状态的，且下一个任务的数据是依赖于上一个的， 在一个时间分片内，如果上一个上午
   被修改了，产生新的结果，react是想要用新的状态继续执行，但是在generator内，只能使用之前的结果。

如何判断是否有高优的任务：
   当前js环境没有办法判断是否有高优任务，所以只能约定一个合理的执行时间， 当超过这个执行时间， 如果任务还没有执行
   完成， 中断当前任务， 控制权交给浏览器。

浏览器有空的时候执行回调：
   requestIdleCallback（）

    浏览器在有空的时候执行回调， 这个回调会执行一个参数， 表示浏览器有多时间执行我们的任务。

   人眼识别大约是16帧， 1000ms/60f = 16ms，一帧约等于60ms，浏览器人为这个是个合理的时间

   浏览器在一帧内要做的事情：
      处理用户的输入
      js执行
      reestAnimation调用
      布局
      绘制等
    一帧的时间减去浏览器执行的日常行为就是有空的时间，去执行回调函数。

浏览器很忙怎么办？
    requestIdleCallback timeout参数， 如果超过这个timeout，回调还没有被执行， 那么会在下一帧强制被执行。

兼容性：
     浏览器兼容性
    触发频率不稳定，受很多因素影响。比如当我们的浏览器切换tab后，之前tab注册的requestIdleCallback触发的频率会变得很低
     基于以上原因，React实现了功能更完备的requestIdleCallbackpolyfill，这就是Scheduler。除了在空闲时触发回调的功能外，
      Scheduler还提供了多种调度优先级供任务设置。

timeout超时后任务一定被执行吗？
    不是的，react订阅了5个优先级等级。同一等级按照推入顺序。
    1.immediate最该优先级， 这个优先级任务马上被执行不能被中断
    2.useBlocking， 这些一般是用户交互的结果， 需要即使得到反馈。
    3.normal 不需要用户立即感受到变化， 比如网络请求
    4.low。这些任务可以延后， 但是最终也需要被执行。
    5.idle 空闲优先级可以无限被延后



