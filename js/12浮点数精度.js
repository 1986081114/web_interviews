0.1 + 0.2 == 0.3 //false 
/*
js中浮点数值使用双精确度，也就是64位字节存储一个浮点数
 把一个小数转换成二进制要不停的循环。
 虽然0.1转换成二进制时是一个无限循环的数，但是计算机要存储
  一个浮点数 (Value) 可以这样表示：Value = sign * exponent * fraction
      比如-1020，用科学计数法表示就是:-1 * 10^3 * 1.02
    所以要存储浮点数就存S（1bit）,E+bais（11），Fraction（52）
    s = 0表示正数，1表示负数
    所以当0.1存储下来就发生了精度丢失。
*/
/*
浮点数运算：
    对阶， 尾数运算，规格化，舍入处理，溢出判断

    0.1+0.2；两次存储的精度丢失和一个运算的精度丢失，
*/

/*
 解决方法：
     1.小数转成二进制会有无限循环的情况， 但是整数除法取余是不会的， 所以整数不会出现精度丢失，
       所以可以把小数转换成整数计算， 计算结果后在除回去
    2.可以使用正确的比较方法---使用js提供的最小精度值：
      Math.abs(0.1+0.2 -0.3) <= Number.EPSILON
*/
/* 
  js中有+0 和-0区别，虽然在加法运算中没有区别，但是在除法中有区别， 检测方法就是检测1/x是infinity还是-infinity
*/