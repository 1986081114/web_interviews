在浏览器地址输入地址：
浏览器进程的ui线程
判断是关键字还是url
0.构建请求：浏览器进程检查url，组装协议，构成完整的url 。浏览器进程通过进程间通信（IPC）把url请求发送给网络进程
1。网络进程接收到url请求后检查本地缓存是否缓存了该请求资源，如果有则将该资源返回给浏览器进程。返回该资源副本并结束请求。
2.如果没有进行网络请求：
        2.1:准备ip和端口：
            使用dns解析查找ip，dns也有缓存， 如果一个域名已经解析过，就会把解析结果缓存下来，
            如果不指定端口，默认就是80；
        2.2: 建立TCP连接
          chrom有个机制，同一个域名只能有6个tcp连接， 如果在同一个域名下有多余6个的请求发生那个，那么多雨的就会进入队列等待排序，
          如果现在不需要等待，建立tcp连接： 三次握手，
        2.3.发送http请求；
             一旦建立tcp连接，浏览器就可以和服务器进行通信， 
             浏览器发送http请求要携带三样东西：请求行，请求头，请求体。
              请求行在一开始构建请求的时候就生成了。
3.网络响应：
   服务器接收到请求并解析，进行相应的处理， 返回。
    与请求类似，网络响应也包括三部分，响应行， 响应头，响应体。
    响应结束，tcp是否断开，还要看connection字段， 如果请求头或者响应头包含connection： keep-alive，
     表示持久连接，这样tcp会议组织保持， 之后请求统一站点资源会复用这个请求。
     否则断开tcp连接。
4.网络进程解析：
   网络进程会使用safebrowing检查数据，是否是恶意站点，如果是则弹出警告
   解析返回来的状态码; 
     如果是301/302，则需要重定向， 从location自动读取地址， 重新请求。
     如果是200，处理请求，根据content-type，判断类型，如果是字节流类型，交给下载管理器，如果是text/html类型，通知浏览器进程交给渲染进程，准备渲染。
5.准备渲染进程：
   会先检查当前url是否有和之前的打开渲染进程的根域名相同，如果相同，使用一个，如果没有相同，创建新的渲染进程。
6.传递数据更新状态：
    渲染进程准备好后，浏览器向渲染进程发起“提交文档”的消息，渲染进程接收到消息和网络进程建立传输数据的“管道”
    渲染进程接收完数据后，向浏览器发送“确认提交”
    浏览器进程接收到确认消息后更新浏览器界面状态：安全、地址栏url、前进后退的历史状态、更新web页面

7.解析:渲染进程主线程
    构建dom树
        转码：浏览器将接收到的二进制数据按照指定编码转化为html字符串
        生成token， parser，将html字符串解析成tokens
        构建nodes， 对node添加对应属性， 通过指针确定，父子关系
        生成domtree，： 通过node1包含的指针确定的关系构建出dom tree
     渲染主线程解析文本， 便解析边加载子资源，js可能会阻塞最后
          主线程会解析数据，标记话， 生成document，并在document下添加子结构最后形成dom树
          在解析过程中如果碰到script，就会停止解析， 请求script资源
    样式计算:
       分为三个阶段：
         格式化样式表  
             浏览器无法识别css样式文件，所以渲染进程收到css文本会执行一个操作， 转化成浏览器理解的stuleSheets
         标准化样式表：
             在写css样式时候，可能会有2rem， red等，不容易被渲染引擎理解，所以需要标准化， em-》px， red-》rageb格式
         计算每个dom节点具体样式
             通过格式化和标准化， 计算规则使用继承和层叠
               继承： 每个节点默认继承父节点的样式，找不到就采用浏览器默认的样式
               层叠：样式层叠：合并来自多个源的属性值的算法
            形成cssom树
    生成布局树：布局
            有了dom树和样式计算，通过浏览器的布局系统，生成布局树（渲染树）
            1.创建布局
         
            2.布局计算
            遍历dom树可见节点：并把这些节点加到布局树，。布局树的结构与 DOM 树的结构十分相似，但是包含每个结点的位置和大小
            但只包含将会在页面中显示的元素。dom树包括head和隐藏节点，渲染树不包括
            当一个元素的样式被设置成 display: none 时，元素就不会出现在布局树中，但那些样式被设置成 visiblility：hidden 
            的元素会出现在布局树中。
            相似的，当我们使用一个包含内容的伪元素（例如p::before { content: 'Hi!' }）时，
            元素会出现在布局树中即使这个元素不存在于 DOM 树中，这也是为什么我们使用 DOM 提供的 API 无法获取伪元素的原因。
 8.绘制 paint
     建立图层树(Layer Tree)
        由于有一些复杂的场景， 比如3d变换，当元素拥有层叠层叠上下文，控制隐藏，需要对布局树分层，构建图层树
         根据显示合成和隐式合成创建新的图层：
           一般节点图层默认属于父节点的图层， 但有时也会提升一个为一个新的合成层。
              显示合成：
                   拥有一些css属性： opacity值不为1， transfrom不为0，position不为static且设置了z-index；
                   需要剪裁（clip）的地方也会被创建为图层。比如超出div的文本可以滚动查看，滚动条会被提升一个单独图层。
               隐式合成： z-index 比较低的会被提升为一个单独的图层，那么所有层叠等级比他高都会形成一个单独的图层
                隐式合成缺点： 根据上面的文章来说，在一个大型的项目中，一个z-index比较低的节点被提升为单独图层后，
                层叠在它上面的元素统统都会提升为单独的图层，我们知道，上千个图层，会增大内存的压力，
                有时候会让页面崩溃。这就是层爆炸
            
    生成绘制列表
       渲染引擎会将图层拆分为一个个绘制指令， 比如先会背景，在画边框，然后将这些指令按顺序组合成一个待绘制列表


    1生成图块并栅格化
       当绘制列表准备好，渲染进程主线程会把列表交给合成线程去渲染
       由于视口大小是有限的，为了避免性能浪费，合成线程第一步就是将图层分块。加快首屏展示
                            
       然后将每个图块交给栅格化线程， 栅格化线程栅格化每个图片并存储在gpu进程中
    显示器显示内容
       栅格化操作完成后，合成线程会收到栅格化线程传过来的DrawQuad信息，这个包含图块的位置和信息，根据这些信息合成器线程生成一个合成器帧
       通过ipc发送给浏览器进程。接着浏览器进程将合成器帧传送给gpu进程
       gpu渲染展示在屏幕上

       当滚动页面生成新的合成器帧再去渲染
       
 
  因为后面图块数据要进入 GPU 内存，考虑到浏览器内存上传到 GPU 内存的操作比较慢，即使是绘制一部分图块，
    也可能会耗费大量时间。针对这个问题，Chrome 采用了一个策略: 在首次合成图块时只采用一个低分辨率的图片，
     这样首屏展示的时候只是展示出低分辨率的图片，这个时候继续进行合成操作，当正常的图块内容绘制完毕后，
    会将当前低分辨率的图块内容替换。这也是 Chrome 底层优化首屏加载速度的一个手段。

为什么很多站点第二次打开速度会快很多：
    主要是一些数据被缓存：
         dns缓存和页面资源被缓存

   渲染进程中，包含线程分别是：

    一个主线程（main thread）

    多个工作线程（work thread）

    一个合成器线程（compositor thread）

    多个光栅化线程（raster thread）

栅格化和合成，不会占用主线程；所以不会占用主线程， transfrom不会重绘重排节省运算时间
    
  
        
栅格化：文档结构，样式，几何位置 绘画顺序等信息转成显示器中的像素， 这个转化的过程叫光栅化。由栅格线程完成。
合成线程会选择视口附近的图块，交给栅格化线程生成位图。
生成视图过程会使用gpu加速， 使用 GPU 生成位图的过程叫快速栅格化，或者 GPU 栅格化，生成的位图被保存在 GPU 内存中

 合成原因：
     传统的做法是将可视区域的内容进行光栅化。随着用户滚动页面，不断的光栅化更多的区域。唯一的缺点就是每当页面滚动，
     光栅线程都需要对新移进视图的内容进行光栅化，这是一定的性能损耗，在展示过程会有延迟

    合成就是将一个页面分成若干层，然后分别对他们光栅化，最后在合成线程里面合并成一个页面的技术。
    当用户滚动页面时，由于页面各个层都已经被光栅化了，浏览器需要做的只是合成一个新的帧来展示滚动后的效果罢了。
    成器线程开始对层次数的每一层进行光栅化。有的层的可以达到整个页面的大小，所以合成线程需要将它们切分为一块又一块的
    小图块（tiles），之后将这些小图块分别进行发送给一系列光栅线程（raster threads）进行光栅化，结束后光栅线程会将
     每个图块的光栅结果存在GPU Process的内存中。

显示器显示图像的原理。
  论是 PC 显示器还是手机屏幕，都有一个固定的刷新频率，一般是 60 HZ，即 60 帧，也就是一秒更新 60 张图片，
  一张图片停留的时间约为 16.7 ms。而每次更新的图片都来自显卡的前缓冲区。而显卡接收到浏览器进程传来的页面后，
  会合成相应的图像，并将图像保存到后缓冲区，然后系统自动将前缓冲区和后缓冲区对换位置，如此循环更新。
  看到这里你也就是明白，当某个动画大量占用内存的时候，浏览器生成图像的时候会变慢，图像传送给显卡就会不及时，
  而显示器还是以不变的频率刷新，因此会出现卡顿，也就是明显的掉帧现象。

         

       




     