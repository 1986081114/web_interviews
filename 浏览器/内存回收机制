浏览器的内存回收机制？如果监控内存泄漏？
5. 紧接着就是一道内存泄漏的题，然后如何改正才能避免内存泄漏? 

.内存的生命周期
   内存分配： 声明变量， 函数，对象的时候，js自动分配
   内存使用：调用的时候，使用的时候，
   内存回收： 不使用自动释放

垃圾回收（GC）： 自动回收， 周期性的执行， 找出那些不再继续使用的变量， 释放其内存
        以全局变量和局部变量来说， 函数中的变量在函数执行结束之后，这些变量就不再被需要了，所以垃圾回收机制识别并释放他们
        而对于全局变量来说， 垃圾回收机制很难判断这些变量什么时候才不被需要，所以尽量少使用全局变量。
        栈内存用完就回收了，堆内存要看是否还有引入判断
引用计数：
   最初的垃圾回收算法。跟踪记录每个值被引用的次数，如果一个值的引用次数是0， 那么就代表这个值不需要了， 
   会立即触发垃圾回收机制回收但如果两个两个变量互相引用， 就不会被回收， 造成内存泄漏（）
    优点： 由于引用计数算法实时监督内存空间的引用数， 当引用数为0，能立即回收该内存空间， 
           引用计数算法能大程度的减少程序的暂停
    缺点： 
           引用计数算法维护一个计数器， 会有额外开销
           不能解决循环引用的问题。


 标记清除： 
     将垃圾回收过程分为标记清除两个阶段， 在标记阶段，从全局对象出发， 遍历所有对象，将可达到的对象做上标记
     在清除阶段， 同样会遍历所有对象， 对没有标记的对象进行清除，

      优点： 可以回收循环应用的对象
      缺点：不会立即回收垃圾对象
          容易产生碎片化空间



几种常见的内存泄漏： 不在用到的内存，没有及时释放
   1.全局变量：可以使用严格模式解决 
             全局变量什么时候自动释放空间很难判断， 所以在开发中尽量避免使用全局变量
    2.未移除的事件绑定：
         dom元素虽然被移除。但元素绑定的事件还在， 如果不及时移出事件，在ie9以下版本容易导致内存泄漏，
         但现在浏览器不存在这个问题了

    3.无效的dom引用 DOM对象添加的属性是一个对象的引用，解决设置为null
          IE7采用了极端的解决方案：离开页面时回收所有DOM树上的元素，其它一概不管。
    4.定时器setInterval/ setTimeout
        他们的回调函数是个闭包，可以将时间定义在外部解决
    5.闭包
        
避免内存泄漏：
       减少全局变量
       减少闭包
       dom操作后设置为null
       使用完数据即使解除 （null）

    


