
编译型语言：编译型语言在执行之前，需要经过编译器编译， 编译后会保留机器能懂的二进制文件， 这样每次运行，都可以直接运行，不需要再编译
 源代码 -（词法分析，语法分析）-》 生成ast- （语义分析）--》 中间代码-- （代码优化）-》二进制文件 --（直接执行）--》 执行
 编译型执行的启动速度会低一些，但是执行速度更快
   
解释型语言：每次运行时都需要经过解释器对程序进行动态的解释和执行。
  原代码--（词法分析， 语法分析）-》ast --（词义分析）--》字节码--执行
  解释型启动速度会快一些，但是执行会慢一些

  



1.生成抽象语法树ast和执行上下文
    第一阶段分词：词法分析， 将一行行代码拆成一个个token， 所谓token就是语法上不可能再拆分，最小的字符
    第二阶段时解析： 语法分析，将上一步生成的token数据按规矩转成ast，如果语法出现错误，终止抛出异常。


2.生成字节码
    解释器Ignition会根据ast生成字节码，并解释执行字节码。

    其实v8一开始没有字节码， 而是直接将ast转换成机器码， 由于执行机器码效率非常高，所以一开始很受欢迎， 但是由于机器码占用的内存非常高， 
    v8需要消耗大量的内存来存放转换后的机器码， 所以引入字节码
    字节码就是介于ast和机器码之间的一种代码， 字节码需要通过解释器将其转换成机器码才能执行

3.执行代码：
    生成字节码接下来就要进入到执行阶段了
    解释器ignition不仅负责生成字节码， 还会解释字节码执行，生成机器码执行，
    字节码仍然需要转换为机器码，但和原来不同的是，现在不用一次性将全部的字节码都转换成机器码，而是通过解释器来逐行执行字节码，
    省去了生成二进制文件的操作，这样就大大降低了内存的压力。

    通常，有一段第一次执行的字节码， 解释器会追条解释执行成机器码，
     如果发现有热点代码，比如一段代码被执行多次， 就称为热代码， 那么后台的编译器TurboFan就
    会把该段热点字节码编译成高效的机器码， 当后续在执行这段代码， 只需要直接执行编译后的机器码就可以。

    JIT（即时编码）： 字节码配合解释器ignition和编译器的turbofan编码方式。：解释器在解释执行字节码的同时，收集信息， 当发现末端代码变热起来， 编译器
    把热点代码转换成机器码， 并保存起来， 以备下次使用。
    编译器和解释器的 根本区别在于前者会编译生成二进制文件但后者不会。
    

    反向优化：在某些特殊情况下热点代码有所改变，热代码会反向编译成字节码，如一个求和函数两个参数一直是数字，当突然有一次传过来的是两个字符串
      就会反向优化， 影响效率
       JS 语言是动态语言，非常之灵活，对象的结构和属性在运行时是可以发生改变的，设想一个问题，如果热代码在某次执行的时候，
       突然其中的某个属性被修改了，那么编译成机器码的热代码还能继续执行吗？答案是肯定不能。这个时候就要使用到优化编译器的反优化了，
       他会将热代码退回到 AST 这一步，这个时候解释器会重新解释执行被修改的代码，如果代码再次被标记为热代码，那么会重复执行优化编译器的这个步骤。
      



  v8的优化策略：
    函数只时被声明没有被调用，不会生成ast
    优化代码