UDP（用户数据包协议）：无状态不可靠传输协议
TCP（控制传输协议）；可靠性，面向连接
  区别：
   1. udp是面向无连接的，而tcp是面向连接的
         udp像发送数据就发送，只是数据的搬运工，不会对数据进行拆分和拼接处理， 只会给数据添加一个udp头标识，
         tcp是全双工， 两边都设有缓存临时存储数据

    2.udp是不可靠的，tcp是可靠的
        udp没有拥塞控制，即使网络出现拥塞，也不会降低传输速率
        udp尽最大可能交付，即不保证可靠交付
    3.udp面向报文，tcp面向字节流
       udp对应用程序程序脚下来的报文，既不合并也不拆分，值增加一个首部，
       tcp一字节流的方式进行传输
    4.udp 有单播，多播，广播的功能， tcp只支持单播
         udp不知支持一对一传输方式， 同样也支持一对多，多对多，多对一的方式
          tcp只一对一
    5. 首部开销
      udp首部开销小，仅8字节， tcp最小20字节


      三次握手主要流程：

  一开始双方处于 CLOSED 状态，然后服务端开始监听某个端口进入 LISTEN 状态
  然后客户端主动发起连接，发送 SYN，然后自己变为 SYN-SENT，seq = x
  服务端收到之后，返回 SYN seq = y 和 ACK ack = x + 1（对于客户端发来的 SYN），自己变成 SYN-REVD
 之后客户端再次发送 ACK seq = x + 1, ack = y + 1给服务端，自己变成 EASTABLISHED 状态，服务端收到 ACK，也进入 ESTABLISHED

 四次挥手

  一开始都处于 ESTABLISH 状态，然后客户端发送 FIN 报文，带上 seq = p，状态变为 FIN-WAIT-1
  服务端收到之后，发送 ACK 确认，ack = p + 1，然后进入 CLOSE-WAIT 状态
  客户端收到之后进入 FIN-WAIT-2  状态
  过了一会等数据处理完，再次发送 FIN、ACK，seq = q，ack = p + 1，进入 LAST-ACK 阶段
  客户端收到 FIN 之后，客户端收到之后进入 TIME_WAIT（等待 2MSL），然后发送 ACK 给服务端 ack = 1 + 1
  服务端收到之后进入 CLOSED 状态




  tcp三次握手原因：
  谢希仁版《计算机网络》中的例子是这样的，“已失效的连接请求报文段” 的产生在这样一种情况下：
  client 发出的第一个连接请求报文段并没有丢失而是在某个网络结点长时间的滞留了，以致延误到连接释放以后的某个时间才到达 server。
  本来这是一个早已失效的报文段。但 server 收到此失效的连接请求报文段后，就误认为是 client 再次发出的一个新的连接请求。
  于是就向 client 发出确认报文段，同意建立连接。假设不采用 “三次握手”，那么只要 server 发出确认，新的连接就建立了。
  由于现在 client 并没有发出建立连接的请求，因此不会理睬 server 的确认，也不会向 server 发送数据。
  但 server 却以为新的运输连接已经建立，并一直等待 client 发来数据。这样，server 的很多资源就白白浪费掉了。
  采用 “三次握手” 的办法可以防止上述现象发生。例如刚才那种情况，client 不会向 server 的确认发出确认。
  server 由于收不到确认，就知道 client 并没有要求建立连接。”。

  三次握手过程中可以携带数据吗？
     第三次握手可以，前两次不可以
      如果前两次可以携带数据， 那么我一旦有人想攻击服务器， 那么它只要在第一次握手SYN中放大量的数据， 服务器就会消耗更多的时间个内存资源处理这些数据，
      加大了服务器被攻击的风向第三次握手的时候客户端已经处于established状态， 并且已经确认服务器接收发送数据的能力，



  四次挥手原因：
      因为TCP是一个全双工协议，必须单独拆除每一条信道。4次挥手的目的是终止数据传输，并回收资源，此时两个端点两个方向的序列号已经没有了任何关系，
    必须等待两方向都没有数据传输时才能拆除虚链路，三次的话，被动关闭端在收到FIN消息之后，
    需要同时回复ACK和Server端的FIN消息。如果Server端在该连接上面并没有Pending的消息要处理，那么是可以的，
    如果Server端还需要等待一段时间才可以关闭另外一个方向的连接，长时间的延迟会导致客户端误认为发送的请求没有到达服务器，从而不断重发关闭请求。


那么问题来了，在客户机A返回确认报文段，进入TIME-WAIT状态后，为什么不能马上结束TCP的连接，
而是还需要再等待2MSL的时间才能正式结束TCP连接呢？
这里主要有两个原因：
是为了保证A发送的最后一个确认报文段能到达B。若这个ACK报文段在传输过程中丢失，处于LAST-ACK状态的服务器B收不到A已发送的FIN+ACK报文段的确认。
B会超时重传这个FIN+ACK报文段，A在2MSL中收到这个重发的FIN+ACK报文段，会再一次重传一次确认报文段，并重新启动2MSL计时器。直至最后B正常收到确认报文段，
两边重新进入CLOSE状态。如果A在TIME-WAIT状态不等待一段时间，而是发送完ACK后立即释放连接，在发生上述情况后，服务器B就无法正常进入CLOSE状态。
同样，防止我们上一篇介绍TCP三次握手中提到的“已失效的连接请求报文段”的出现。A发送完最后一个确认报文段后，
经过2MSL后，可以使本连接持续时间内产生的所有报文段都从网络中消失。这样，就可以保证下一个新的连接中，不会出现这种旧的连接请求报文段。
以上，就是我们常说的TCP的四次挥手，也就是TCP的连接释放过程.
1MSL：确保四次挥手的主动关闭方最会的ACK报文到达对端
1MSL确保对端收到ACK重传FIN报文可以到达

在 TCP 链接中，对于发送端和接收端而言，TCP 需要把发送的数据放到发送缓存区, 将接收的数据放到接收缓存区。而经常会存在发送端发送过多，
而接收端无法消化的情况，所以就需要流量控制，就是在通过接收缓存区的大小，控制发送端的发送。如果对方的接收缓存区满了，就不能再继续发送了。
而这种流量控制的过程就需要在发送端维护一个发送窗口，在接收端维持一个接收窗口。


滑动窗口： 发送窗口，接收窗口

发送窗口：
  其中包含四大部分:

    已发送且已确认
    已发送但未确认
    未发送但可以发送
    未发送也不可以发送

tcp可靠传输：
  停止等待协议： 停止等待就是每发送完一个分组就停止发送，等待对方的确认。在收到确认后再发送下一个分组。
     为保证可靠性， 需要配合连续ARQ协议和滑动窗口协议

     ARQ协议：
      发送方维护一个一定大小的发送窗口， 位于发送窗口内的所有分组都可以连续发送出去， 中途不需要等待对方确认，发送方在没收到一个确认时就把发送窗口向前互动一个分组
       通常接收方采用累计确认的方式， 不必对收到的分组逐个发送确认， 而是在收到几个分组之后，再发送确认，

  拥塞处理和流量控制不同，后者是作用于接收方，保证接收方来得及接受数据。
  而前者是作用于网络，防止过多的数据拥塞网络，避免出现网络负载过大的情况。

#慢开始算法

      流量控制： 指的是控制发送方的发送速率， 以便接收方来得及接收；
      拥塞控制：
             网络拥塞就是传输的数据超过节点承受能力而导致传输能力下降的情况，拥塞控制就是为了防止过多的数据注入到网络而造成路由器过载
            慢启动：由于不知知道网络的负载能力，最好选择de就是逐步探索，由小到大成倍的增大发送窗口， 
            拥塞避免：让滑动窗口缓慢增大， +1， 慢启动和拥塞控制通常配合使用， 
            快重传： 在 TCP 传输过程中，如果发生了丢包，接收端就会发送之前重复 ACK，比如 第 5 个包丢了，6、7 达到，
                    然后接收端会为 5，6，7 都发送第四个包的 ACK，这个时候发送端受到了 3 个（其实是四个，第一个是正常的）重复的 ACK，意识到丢包了，
                    就会马上进行重传，而不用等到 RTO （超时重传的时间）
            快恢复：
              如果发送端收到了 3 个重复的 ACK，发现了丢包，觉得现在的网络状况已经进入拥塞状态了，那么就会进入快速恢复阶段：
            会将拥塞阈值降低为 拥塞窗口的一半
            然后拥塞窗口大小变为拥塞阈值
            接着 拥塞窗口再进行线性增加，以适应网络状况

 tcp可靠体现在：有状态、可控制

  有状态是指 TCP 会确认发送了哪些报文，接收方受到了哪些报文，哪些没有收到，保证数据包按序到达，不允许有差错
  可控制的是指，如果出现丢包或者网络状况不佳，则会跳转自己的行为，减少发送的速度或者重发

  为什么快重传是3个ack：
   使发送端是按序发送，由于TCP包是封装在IP包内，IP包在传输时乱序，意味着TCP包到达接收端也是乱序的，后面发送的先到达了。
   乱序的话也会造成接收端发送冗余ACK。那发送冗余ACK是由于乱序造成的还是包丢失造成的，这里便需要好好权衡一番，
   因为把3次冗余ACK作为判定丢失的准则其本身就是估计值。
      
  超时重传时间：
     经典方法引入了一个新的概念——SRTT(Smoothed round trip time，即平滑往返时间)，没产生一次新的 RTT. 就根据一定的算法对 SRTT 进行更新，具体而言，计算方式如下(SRTT 初始值为0):
    SRTT =  (α * SRTT) + ((1 - α) * RTT)
    复制代码
    其中，α 是平滑因子，建议值是0.8，范围是0.8 ~ 0.9。
    拿到 SRTT，我们就可以计算 RTO 的值了:
    RTO = min(ubound, max(lbound, β * SRTT))
    复制代码
    β 是加权因子，一般为1.3 ~ 2.0， lbound 是下界，ubound 是上界。

    


   