  HTTP 0.9：1991年,原型版本，功能简陋，只有一个命令GET,只支持纯文本内容，该版本已过时。

  HTTP 1.0
  除了GET命令，还引入了POST命令和HEAD命令。
  只使用 header 中的 If-Modified-Since 和 Expires 作为缓存失效的标准。
  不支持断点续传，也就是说，每次都会传送全部的页面和数据。
  通常每台计算机只能绑定一个 IP，所以请求消息中的 URL 并没有传递主机名（hostname）

  HTTP 1.1 http1.1是目前最为主流的http协议版本，从1999年发布至今，仍是主流的http协议版本。
  引入了持久连接（ persistent connection），即TCP连接默认不关闭，可以被多个请求复用，不用声明Connection: keep-alive。长连接的连接时长可以通过请求头中的 keep-alive 来设置
  引入了管道机制（ pipelining），即在同一个TCP连接里，客户端可以同时发送多个 请求，进一步改进了HTTP协议的效率。管线化机制需要通过
永久连接（Persistent Connection）完成，并且只有GET和HEAD等请求,可以进行管线化，使用场景有很大的限制。
  HTTP 1.1 中新增加了ETag，Cache-Control… 等缓存控制标头来控制缓存失效。
  支持断点续传，通过使用请求头中的 Range 来实现。
  使用了虚拟网络，在一台物理服务器上可以存在多个虚拟主机（Multi-homed Web Servers），并且它们共享一个IP地址。
  新增方法：PUT、 PATCH、 OPTIONS、 DELETE。
  错误通知的管理，在HTTP1.1中新增了24个错误状态响应码，如409（Conflict）表示请求的资源与资源的当前状态发生冲突；410（Gone）表示服务器上的某个资源被永久性的删除…

http1.x版本问题
在传输数据过程中，所有内容都是明文，客户端和服务器端都无法验证对方的身份，无法保证数据的安全性。
HTTP/1.1 版本默认允许复用TCP连接，但是在同一个TCP连接里，所有数据通信是按次序进行的，服务器通常在处理完一个回应后，才会继续去处理下一个，这样子就会造成队头阻塞。
http/1.x 版本支持Keep-alive，用此方案来弥补创建多次连接产生的延迟，但是同样会给服务器带来压力，并且的话，
          对于单文件被不断请求的服务，Keep-alive会极大影响性能，因为它在文件被请求之后还保持了不必要的连接很长时间。

HTTP 2.0
二进制分帧 这是一次彻底的二进制协议，头信息和数据体都是二进制，并且统称为"帧"：头信息帧和数据帧。
头部压缩（HPACK算法） HTTP 1.1版本会出现 User-Agent、Cookie、Accept、Server、Range 等字段可能会占用几百甚至几千字节，
          而 Body 却经常只有几十字节，所以导致头部偏重。HTTP 2.0 使用 HPACK 算法进行压缩。
SPDY协议:解决网络延迟和安全性能，http和tcp之前的会话层协议，核心思想是多路复用， 复用TCP连接，在一个连接里，客户端和浏览器都可以不同请求可以互相穿插，避免了http层面的请求队头阻塞。
          ，且不用按顺序一一对应，这样子解决了http队头阻塞的问题。但是spdy必须建立在ssl之上，这也是他的限制。
  特征：
     利用一个tcp传输不限个数的资源请求的读写数据流
     根据资源请求的特征和优先级，spdy可以调整优先级
     使用压缩技术，减少传递的字节数

服务器推送 允许服务器未经请求，主动向客户端发送资源，即服务器推送。
    对每一个希望发送的资源，服务器会发送一个PUSH_PROMISE帧，客户端可以通过发送RST_STREAM帧来拒绝推送（当资源已经位于缓存）。
    这一步的操作先于父响应（index.html），客户端了解到服务器端打算推送哪些资源，就不会再为这些资源创建重复请求。
    当客户端收到index.html的响应时，script.js和style.css已经位于缓存。
    当用户需要浏览某个网页，支持spdy协议的服务器在发送资源给浏览器时，可以发送一些后面可能用到的资源，浏览器可以提前知道并确定是否下载，更极端可以主动发送资源。

请求优先级 可以设置数据帧的优先级，让服务端先处理重要资源，优化用户体验。

头部压缩原理：  
    头部压缩使用了HPACK算法
    维护了一份相同的静态字典， 包含常见的头部名称和头部名称和值的组合， 这样可以用少量的字符代替头部键值对
    维护了一份相同的动态字典， 可以动态添加内容
    支持基于静态的哈夫曼编码表的哈夫曼编码

 	HTTP/1.1 中的管道（ pipeline）传输中如果有一个请求阻塞了，那么队列后请求也统统被阻塞住了
•	HTTP/2 解决了http对头阻塞，但是没有解决tcp的对头阻塞多请求复用一个TCP连接，一旦发生丢包，就会阻塞住所有的 HTTP 请求。

HTTP/1.0 每次请求响应，建立一个TCP连接，用完关闭
HTTP/1.1 「长连接」 若干个请求排队串行化单线程处理，后面的请求等待前面请求的返回才能获得执行机会，一旦有某请求超时等，后续请求只能被阻塞，
  毫无办法，也就是人们常说的线头阻塞；
HTTP/2.0 「多路复用」多个请求可同时在一个连接上并行执行，某个请求任务耗时严重，不会影响到其它连接的正常执行；


  1. TCP队头阻塞
     TCP数据包是有序传输，中间一个数据包丢失，会等待该数据包重传，造成后面的数据包的阻塞。


                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 v vvvvvvvvv,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,,
http3.0: 虽然http2解决了很多旧版本的问题， 但是依旧有一个巨大的问题， 就是底层支撑的tcp协议造成的， 

   http2.0缺点： tcp连接依旧耗时，最少要耗费1.5个rtt之后才能进行数据传输。如果是tls大约需要1-2个rtt
                tcp对头阻塞并没有完全解决， 多个请求泡在tcp管道里， 发生丢包时，有个丢包重传机制，丢失的包必须要等待
                重新传输确认， http/2丢包时， 整个tcp都要开始等待重传，会阻塞tcp连接中的所有请求。http1.1中开启多个tcp连接
                出现丢包只会影响其中一个请求。 剩下的tcp连接还可以正常传输数据。
  http3.0就完美结局了队头阻塞的问题。
    http3.0让http跑在quic而不是tcp。quic时基于udp的。
    quic新功能， 
         quic基于udp，udp是无连接的，不需要握手挥手， 速度更快， quic自己实现了可靠传输， 保证数据到达目的地。
          还引入了http2的liu和多路复用，每个流是有序的， 即使发生丢包， 其他流也不会受到影响。

          



