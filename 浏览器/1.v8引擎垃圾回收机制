1.为什么需要垃圾回收？
  在执行js代码过程中，当遇到函数调用，会为其创建一个函数执行上下文， 并将其添加到栈堆的栈顶，函数的作用域中包含该函数
  声明的所有的变量， 当该函数执行完毕， 对应的执行上下文从栈顶弹出， 函数的作用域也随之销毁。其包含的变量也会同意释放并被自动回收， 
  如果在作用域销毁的过程中，其中变量不被回收， 持久占用内存，必然导致内存爆炸，引发内存泄漏，导致程序崩溃

2.v8在64位系统做多使用1.4g的内存， 在32位最多使用0.7g，为什么设置这么小呢？
    2.0表层原因是v8最初是为了浏览器设置的，不太可能遇到大量内存的场景，对于网页来讲v8限制绰绰有余了。
     2.1.但是js单线程机制（js作为脚本原因呢，主要用途是与用户交互以及操作DOM， 那么这也决定了其作为单线程的本质） 单线程意味着执行的代码
        必须按照顺序，只能同时处理一个任务。既然js是单线程的，那么就意味着在v8执行垃圾回收机制，程序中的其他逻辑都要进入
        暂时等待阶段。 等待垃圾回收结束再次重新执行。
    2.2.而垃圾回收机制本身是一件耗时的操作， 如果堆内存设置过大， 耗时更久， 浏览器在这期间一直等待，失去对用户的响应，影响用户体验
     和程序性能。

     当然也可以运行 node --max-old-space-size 或 node --max-new-space-size调整内存限制的大小。
     前者单位MB ，对应老生带内存， 后者对应单位kb，用于新生代内存。这两个值在启动时就被设置，所v8内存使用内存无法根据环境自动扩充。

3.v8垃圾回收策略： 
     因为在现实的场景中， 对象的生长周期是不同的，不同的算法只针对特定的情况玉偶最好的效果，为此产生分代式垃圾回收策略。
      分代式垃圾回收机制：根据对象的存活时间将内存的垃圾回收进行不同的分代，，然后对不同的分代内存采用不同的垃圾回收算法

4. v8的堆结构：v8中所有的对象都是通过堆来进行分配的
        新生代： 大多数的对象开始被分配在这里， 这个区域相对较小但是垃圾回收特别频繁， 该区域被分为两半，一半用来分配内存，
            另一半保存垃圾回收将要保存的对象。
        老生代： 新生代中的对象在存活一段时间后将会被转移到老生代内存中。相对于新生代，垃圾回收频率较低。老生代分为
             老生代指针区和老生代数据区。 前者包含大多数可能存在指向其他对象的指针的对象，后者保存原始数据对象。
        大对象区： 存放体积超级大的对象
        代码区：代码对下那个被分配在这里
        map区： 存放cell和mao

   4.1新生代： 存放存活时间较短的对象，垃圾回收过程中主要采用了Scavenge算法,在64位和32位系统下内存最大值为32mb和16mb
         scavenge主要采用Cheney算法: 是一种采用复制的方式实现垃圾回收算法,
          是一种典型的牺牲空间换取时间的算法， 它将新生代内存一分为二，一个区域处于激活(使用)状态叫from区域
          未激活（未使用）的区域叫to空间， 在这两个空间始终有一个处于使用状态。另一个闲置状态。程序中声明的对象首先会被分配到from区域
          再进行垃圾回收机制，如果from空间由存活对象，会被复制到to区，非存活对象被回收， 当结束后，from与to空间进行角色互换，
           to空间变成新的from空间， 原来的from空间变成to空间。（复制过去，from区域变量都删除，可以防止碎片化空间）
         scavenge算法垃圾回收过程主要是将存活对象在from空间和to进行复制，同时完成角色互换， 此算法缺点也很明显，浪费一半的内存
              用于复制，但是由于只复制存活的对象，并且对于生命周期短的场景存活对象只占少部分，所以在时间效率表现优异。
   4.2：对象晋升：
      当一个对象在经过多次复制之后依旧存活那么它会被认为是一个生命周期较长的对象。在下一次进行垃圾回收时。该对象被直接转移到老生代中
       这种转移称为晋升。
         晋升要求：对象经历过一侧scavenge算法
                   to空间内存占比超过25%。
        在新生代进行垃圾回收再将对象从from复制到to区，会先检查对象的内存地址是否经历过一次scavenge算法，如果地址已经发生改变
         就将该对象晋升到老生代，不复制到to空间。
          如果对象没有经理过scavenge算法，会被复制到to区，但是此时to空间内存比高于25%，则转移该对象到老生代。
          之所以是25%内存比，是因为to空间在经历一次scavenge算法后会和from转换，后续的内存分配都是在from空间进行，如果内存使用过高
          会影响后续内存的分配，
    4.3老生代： 
        在老生代管理者大量存活对象， 如果依旧使用scavenge算法，会浪费一半的内存，所以使用新的算法标记清除和标记整理进行垃圾回收
        在早前使用引用计数，算法原理很简单，就是看对象是否还有其他的引用指向它，如果没有，就会被回收。但是循环引用就会内存泄漏
        采用标记清除和标记整理，循环引用的对象无法访问到，因此无法标记，被回收

        标记清除：分为标记和清除两个阶段，在标记阶段从全局对象出发开始遍历堆中的所有的对象，标记活着的对象。在清除阶段对未标记的对象清除.
                垃圾回收器会在内部创建一个根列表， 用于从根节点（window）出发访问那些可以被访问到的对象， 
                然后，垃圾回收器从根节点出发，遍历所有可以被访问的变量进行标记，最后垃圾回收器释放哪些非标记的变量。
                根节点： 全局对象， 本地函数局部变量和参数，当前嵌套调用链上的其他函数的变量和参数

                但是经历一次标记清除，清理的内存对象地址可能不连续，出现内存碎片问题， 导致后续如果分配一个大对象而内存不足分配
                 提前触发垃圾回收。
                
        标记整理：解决碎片话问题。是在标记清除的基础上提出标记整理。
                 在整理的过程中，会将活动的对象往堆内的一端进行移动， 移动完成后在清理边界外的全部内存。

        由于标记整理需要移动对象，所以执行速度是最慢的，v8在取舍上，主要是用的标记清除，在内存空间不足以对从新生代晋升过来对象
        进行分配时，才使用标记整理。

        可以看出scavenge只复制活的对象， 标记清除只清理死的对象，活对象在新生代占比很小，死对象在老生代占比很小，
        这是两种回收方式能够高效处理的原因。
                
        由于js单线程且为了避免js应用程序和垃圾回收器看到的不一致的情况 在进行垃圾回收时会阻塞主线程执行，应用程序暂停，
        等待垃圾回收后在恢复执行的逻辑这种行为被称为全停顿。在v8垃圾回收中，新生代默认配置比较小，且存在的活对象通常较少
        所以即使是全停顿影响也不大，但是老生代通常配置比较大，且存活对象比较多， 全堆垃圾回收的标记，清除，整理造成的停顿会比较长。
        势必造成严重卡顿。因此v8引擎又引入增量标记概念。

        增量标记： 将原本需要一次性遍历堆内存的操作改为增量标记的方法， 先标记堆内存的一部分对象，然后暂停， 将执行权重新交给js线程
                 待主线程任务执行完毕，再从原来早听的地方继续标记，交替执行直到标记整个堆内存.
                 得益于增量标记的好处，V8引擎后续继续引入了延迟清理(lazy sweeping)和增量式整理(incremental compaction)，
                 让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入并行标记和并行清理，
                 进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。


5.避免内存泄漏 高效使用内存：  

        1.尽可能少使用全局变量： 
           创建全局变量挂载到window， 在标记清除阶段，因为window对象作为根节点，window上的对象都可以被访问到， 因此不会被垃圾回收
            只有当整个线程退出时全局作用域才被销毁，因此如果非要使用，在设置完毕将其设置为null或者undefined。
        2.手动清除定时器
          定时器内的变量一直在调用 ，不会被回收
        3.少用闭包：
            闭包会导致外部引入函数不会被释放，占用内存。 
        4.清除dom引用：
          const elements = {
              button: document.getElementById('button')
          };
          function removeButton() {
              document.body.removeChild(document.getElementById('button'));
          }
复制代码在这个示例中，我们想调用removeButton方法来清除button元素.
但是由于在elements字典中存在对button元素的引用，所以即使我们通过removeChild方法移除了button元素，
它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对button元素的引用才会被垃圾回收。

node的内存并非都是通过v8进行分配的，那些不经过v8分配的内存叫 端外内存。
利用端外内存可以突破内存限制的的问题， 不如Buffer， v8的垃圾回收机制限制的主要是v8的堆内存。
Buffer 对象不经过v8的内存分配，所以不会有堆内存的大小的限制。



