1.为什么需要垃圾回收？
  在执行js代码过程中，当遇到函数调用，会为其创建一个函数执行上下文， 并将其添加到栈堆的栈顶，函数的作用域中包含该函数
  声明的所有的变量， 当该函数执行完毕， 对应的执行上下文从栈顶弹出， 函数的作用域也随之销毁。其包含的变量也会同意释放并被自动回收， 
  如果在作用域销毁的过程中，其中变量不被回收， 持久占用内存，必然导致内存爆炸，引发内存泄漏，导致程序崩溃

2.v8在64位系统做多使用1.4g的内存， 在32位最多使用0.7g，为什么设置这么小呢？
     2.1.js单线程机制， js作为脚本原因呢，主要用途是与用户交互以及操作DOM， 那么这也决定了其作为单线程的本质， 单线程意味着执行的代码
        必须按照顺序，只能同时处理一个任务。既然js是单线程的，那么就意味着在v8执行垃圾回收机制，程序中的其他逻辑都要进入
        暂时等待阶段。 指代垃圾回收结束再次重新执行， 。垃圾回收阻塞了程序的运行。
    2.2.垃圾回收机制，本身是一件耗时的操作， 如果堆内存设置过大， 耗时更久， 浏览器在这期间一直等待，失去对用户的响应，影响用户体验
     和程序性能。

3.v8垃圾回收策略： 
        分代式垃圾回收机制：根据对象的存活时间将内存的垃圾回收进行不同的分代，，然后对不同的分代采用不同的垃圾回收算法

4. v8的堆结构：
        新生代： 大多数的对象开始被分配在这里， 这个区域相对较小但是垃圾回收特别频繁， 该区域被分为两半，一半用来分配内存，
            另一半保存垃圾回收将要保存的对象。
        老生代： 新生代中的对象在存活一段时间后将会被转移到老生代内存中。相对于新生代，垃圾回收频率较低。老生代分为
           老生代指针区和老生代数据区。 前者包含大多数可能存在指向其他对象的指针的对象，后者保存原始数据对象。
        大对象区： 存放体积超级大的对象
        代码区：代码对下那个被分配在这里
        map区： 存放cell和mao

   4.1新生代： 存放存活时间较短的对象，垃圾回收过程中主要采用了Scavenge算法
         Scavenge： 算法是一种典型的牺牲空间换取时间的算法， 它将新生代内存一分为二，一个区域处于激活状态叫from区域
          未激活的区域叫to空间， 在这两个空间始终有一个处于使用状态。另一个闲置状态。程序中声明的对象首先会被分配到from区域
          再进行垃圾回收机制，如果from空间由存活对象，会被复制到to区，非存活对象被回收， 当结束后，from与to空间进行角色互换，
           to空间变成新的from空间， 原来的from空间变成to空间。（复制过去，from区域变量都删除，可以防止碎片化空间）
         scavenge算法垃圾回收过程主要是将存活对象在from空间和to进行复制，同时完成角色互换， 此算法缺点也很明显，浪费一般的内存
              用于复制
   4.2：对象晋升：
      当一个对象在经过多次复制之后依旧存活那么它会被认为i是一个生命周期较长的对象。在下一次进行垃圾回收时。该对象被直接转移到老生代中
       这种转移称为晋升。
         晋升要求：对象经历过一侧scavenge算法
                   to空间内存占比超过25%。
        在新生代进行垃圾回收再将对象从from复制到to区，会先检查对象的内存地址是否经历过一次scavenge算法，如果地址已经发生改变
         就将该对象晋升到老生代，不复制到to空间。
          如果对象没有经理过scavenge算法，会被复制到to区，但是此时to空间内存比高于25%，则转移该对象到老生代。
          之所以是25%内存比，是因为to空间在经历一次scavenge算法后会和from转换，后续的内存分配都是在from空间进行，如果内存使用过高
          会影响后续对象的分配，
    4.3老生代： 
        在老生代管理者大量的存活对象， 如果依旧使用scavenge算法，会浪费一半的内存，所以使用新的算法标记清除和标记整理管理
        在早前使用引用计数，算法原理很简单，就是看对象是否还有其他的引用指向它，如果没有，就会被回收。但是循环引用就会内存泄漏
        采用标记清除和标记整理，循环引用的对象无法访问到，因此无法标记，被回收

        标记清除：分为标记和清除两个阶段，在标记阶段从全局对象出发开始遍历堆中的所有的对象，标记活着的对象，在清除阶段对未标记的对象清除.
                垃圾回收器会在内部创建一个根列表， 用于从根节点（window）出发访问那些可以被访问到的对象， 
                然后，垃圾回收器从根节点出发，遍历所有可以被访问的变量， 标记，
                最后垃圾回收器释放哪些非活动的变量

                根节点： 全局对象， 本地函数局部变量和参数，当前嵌套调用链上的其他函数的变量合参宿

                但是经历一次标记清除，清理的内存对象地址可能不连续，出现内存碎片问题， 导致后续如果分配一个大对象而内存不足分配
                 提前触发垃圾回收。
        标记整理：解决碎片话问题。
                 在整理的过程中，会将活动的队形往堆内的一段进行移动， 移动完成后在清理边界外的全部内存。
                由于js单线程， 在进行垃圾回收会阻塞主线程执行，造成全停顿，标记阶段也会阻塞 一般来说，老生代会保存大量存活的对象， 如果在
                标记阶段将整个堆内存，遍历一遍，势必造成严重卡顿。因此v8引擎又引入增量标记概念
                 增量标记： 将原本需要一次性遍历堆内存的操作改为增量标记的方法， 先标记堆内存的一部分对象， 然后暂停， 将执行权重新交给js线程
                 待主线程任务执行完毕，再从原来早听的地方继续标记，直到标记整个堆内存， 
                 得益于增量标记的好处，V8引擎后续继续引入了延迟清理(lazy sweeping)和增量式整理(incremental compaction)，
                 让清理和整理的过程也变成增量式的。同时为了充分利用多核CPU的性能，也将引入并行标记和并行清理，
                 进一步地减少垃圾回收对主线程的影响，为应用提升更多的性能。



5.避免内存泄漏：  
        1.尽可能少使用全局变量： 
           创建全局变量挂载到window， 在标记清除阶段，因为window对象作为根节点，window上的对象都可以被访问到， 因此不会被垃圾回收
            只有当整个线程退出时全局作用域才被销毁，因此若果非要使用，在设置完毕将其设置为null
        2.手动清除定时器
          定时器内的变量一直在调用 ，不会被回收
        3.少用闭包：
            一般来说，我们在查找变量时，在本地作用域中查找不到就会沿着作用域链从内向外单向查找，但是闭包的特性可以让我们在外部作用域访问内部作用域中的变量，示例如下：
        4.清除dom引用：
          const elements = {
    button: document.getElementById('button')
};

function removeButton() {
    document.body.removeChild(document.getElementById('button'));
}
复制代码在这个示例中，我们想调用removeButton方法来清除button元素，】
但是由于在elements字典中存在对button元素的引用，所以即使我们通过removeChild方法移除了button元素，
它其实还是依旧存储在内存中无法得到释放，只有我们手动清除对button元素的引用才会被垃圾回收。

