1.http:超文本传输协议
 https: 超文本传输安全协议 是以安全为目的的HTTP通道，是http的安全版

  区别： 
     1.http的url是以http开头吗，而https是https开头
     2.http标准端口是80， 而https标准端口是443
     3http使用明文传输， 不会验证通信方的身份， https则是具有安全性的ssl加密传输协议， 并且通过整数验证身份
     4.HTTP 页面响应速度比 HTTPS 快，主要是因为 HTTP 使用 TCP 三次握手建立连接，客户端和服务器需要交换 3 个包，而 HTTPS除了
        TCP 的三个包，还要加上 ssl 握手需要的 9 个包，所以一共是 12 个包。

 2.http的请求方法有哪些？get、post的区别，别的方法是干什么的
    get post 区别
       2.1 GET参数通过URL传递，POST放在message body中。get不能再body传递参数， 到那时post可以在url传递参数
          get是把参数数据队列加到提交表单的ACTION属性所指的URL中，值和表单内各个字段一一对应，在URL中可以看到。
            post是通过HTTPpost机制，将表单内各个字段与其内容放置在HTML HEADER内一起传送到ACTION属性所指的URL地址。用户看不到这个过程。
       2.2get传送的数据有长度限制， 而post没有限制
       2.3安全性问题， 使用get参数会显示在地址栏， 而post不会，所以安全性会很低
       2.4get从服务器获取数据， post主要对数据增删改。
       2.6get在回退时，是无害的， 而post再次提交
       2.7get请求会被浏览器主动缓存，post不会
       2.8对参数的数据类型，GET只接受ASCII字符，而POST没有限制。
       2.9ET和POST还有一个重大区别
                对于GET方式的请求，浏览器会把http header和data一并发送出去，服务器响应200（返回数据）；
                而对于POST，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok（返回数据）。
                (火狐浏览器除外，它的 POST 请求只发一个 TCP 包)
      。

    get：获取资源 ，幂等的（1.0，1.1）
    post：传输实体主体 不幂等， 多个请求后一个不会吧前一个覆盖掉（1.0，1.1）
    put：传输文件，幂等， 多个请求 后一个会把前一个覆盖，（更改）（1.0，1.1）
    head： 获得报文首部， 和get类似只是不返回报文主体部分（1.0，1.1）
    delete：删除文件，幂等（1.0，1.1）
    options：询问支持的方法 （1.1）
     OPTIONS请求方法的主要用途有两个：
         获取服务器支持的HTTP请求方法；也是黑客经常使用的方法。
         用来检查服务器的性能。例如：AJAX进行跨域请求时的预检，需要向另外一个域名的资源发送一个options请求头，用以判断实际发送的请求是否安全。
    trace：追踪路径（1.1） 让web服务器将之前的请求通信环回给客户端的方法
    connect：要求使用隧道协议连接代理（1.1），与代理服务器通信时建立隧道，实现用隧道协议进行通信

    PATCH 和 PUT 的区别
PATCH 是 2010 后成为的正式 http 方法，它是对 PUT 的补充。在没有 PATCH 之前，都是用 PUT 进行更新操作，这时候我们的接口中通常会有一个逻辑规则，
如：如果对象的一个属性值为null，那么就不更新该属性（字段）值，通过这种方式来避免全部覆盖的操作。现在有了 PATCH 就解决了这种判断，
在 PUT 操作中不管属性是不是 null，都进行更新，在 PATCH 接口中就对非 null 的进行更新。另外，PATCH 是非幂等的。


3.
HTTP中间人攻击： 
   http协议中报文都是以明文的方式进行传输，不做加密，而且不会验证通信方的身份， 因此可能会遭到伪装
    例如，客户端给服务端发送一个请求A，由于输入信息是明文的，这个信息有可能被某个中间人恶意截获篡改，这种行为就加叫做中间人攻击
        对称加密： 客户端和服务端实现约定一种加密方式，并且约定一个随机生成的密钥，后续的通信中，信息发送都是用密钥对信息加密，
        而信息接收方通过相同的密钥对信息解密
                  但也不是绝对安全的， 虽然我们在后续的通信中对明文进行了加密，但是第一次约定加密方式和密钥的通信任然是明文，
                  如果第一次就被拦截，密钥就会泄露
                  中间人仍然可以揭秘后续所有的通信内容。
        非对称加密：非对称加密的一组密钥包含一个公钥一个私钥，明文既可以用公钥加密私钥解密，也可以用私钥加密，公钥解密。
             建立通信中，客户端首先将自己的公钥key1发送给服务端，
             服务端使用生成一个用于加密的密钥key2，并且用key1加密，发送给客户端
             客户端利用非对称加密的私钥，即开公钥key1的加密得到key2，从此两人用key2进行对称加密
             虽然中间人不知道key1的私钥是多少，但是可以偷天换日， 自己生成一堆公钥私钥，把自己的公钥key3发给服务端，
             服务端不知道key3是属于中间人的， 按照之前的流程key3加密key2，
             中间人截取这一次通信， 解开key3的加密，得到key2，然后再用客户端发来的key1加密发送给客户端。
             这样尽管双方通信用key2进行了加密， 也可以被中间人进行解密。


    如果中间人也想机构申请证书，并把服务端证书偷换自己的证书？ 
               
      证书签名都是由服务端网址等信息生成，并且经过机构加密，中间人无法篡改，发送给客户端的证书是无法通过验证的。


https握手（加密）过程
  https采用对称加密算法加密数据 + 非对称加密算法交换密钥 +数字证书验证身份 = 安全 
  对称加密原因： 非对称加密的加密解密效率非常低，而http的应用场景中通常端到端存在大量的交互，非对称加密的效率无法接受。
                而且一对公私钥只能实现单向的加解密， 而且也不愿意把自己的私钥发送给别人。
  非对称加密：实现身份认证和密钥协商，

  https将报文直接将信息传递给ssl套接宇进行加密，ssl加密后将报文发送给TCP，tcp将加密后的报文发送给目的主机。
  目的主机获取后，使用ssl解密在发给对应进程、

   握手过程：
      1.客户端向服务器发送请求，请求中包括客户端支持的tls协议版本号，还有一个"client random"随机字符串，客户端支持的加密方法
      2.服务器端接受到请求后，确认双方支持的加密算法，tls协议版本，并给出服务器的证书，以及一个server random"随机字符串。
      3.客户端收到服务器的证书后，客户端的ssl验证证书合法性以及是否吊销等，生成数随机字符串"premaster secret，
          浏览器安装后会自动带一些权威第三方机构公钥，使用匹配的公钥对数字签名进行解密。得到消息摘要
        根据签名生成的规则对网站信息进行本地消息摘要生成，然后两者比对。
        通过比对两者签名，匹配则说明认证通过，不匹配则获取证书失败。
      4.使用服务器公钥（证书的公钥）加密这个对称密钥，解密客户端的随机数premaster secret（私钥），
       
      5.：客户端和服务器均使用 client random，server random 和 premaster secret，
     6.并通过商量好的加密算法生成同的共享密钥 KEY。
      7. 客户端就绪：客户端发送经过共享密钥 KEY加密过的"finished"信号。
     8. 服务器就绪：服务器发送经过共享密钥 KEY加密过的"finished"信号。
    达成安全通信：握手完成，双方使用对称加密进行安全通信。

客户端如何验证证书的合法性：
   首先浏览器读取证书中的证书所有者、有效期等信息进行一一校验。
   浏览器开始查找操作系统中已内置的受信任的证书发布机构 CA，与服务器发来的证书中的颁发者 CA 比对，用于校验证书是否为合法机构颁发。
   如果找不到，浏览器就会报错，说明服务器发来的证书是不可信任的。如果找到，那么浏览器就会从操作系统中取出颁发者 CA 的公钥，
       然后对服务器发来的证书里面的签名进行解密。
   浏览器使用相同的 Hash 算法根据证书内容计算出信息摘要，将这个计算的值与证书解密的值做对比。
   对比结果一致，则证明服务器发来的证书合法，没有被冒充。此时浏览器就可以读取证书中的公钥，用于后续加密了。

数字签名：
   数字签名的产生就是为了解决http中内容可能被篡改的问题， 
   生成数字签名：
       1.通过Hash函数处理明文信息生成一个信息摘要；2
       .再用认证机构自己的私钥对信息摘要进行加密处理。通过这两个步骤生成的文件就叫数字签名。
   验证：
       发送方将原文和数字签名发送给接收方
       接收方用hash函数处理原文会得到一份消息摘要
       接收方用机构的公钥解密数字签名， 得到一分消息摘要， 对比
       客户端还会验证证书相关的域名信息，有效时间，是不是在CRL吊销列表里，以及它的上一级是否有效等等。



    HTTPS中间人攻击：

      攻击过程： 
        客户端像服务端发送请求，申请公钥，被拦截
        拦截者像服务器发送请求要公钥，
        服务器向客户端发送公钥
        攻击者截取公钥，保留在就自己手上，
        攻击者伪造公钥发给客户端。
        客户端收到伪造公钥后，生成加密hash发给服务端，
        攻击者获取加密hash，然后用自己的私钥解密获得加密方法，和随机数，获得真密钥，
        同时生成假的加密hash值，发给服务器。
        服务器用私钥解密获得假秘钥。
        服务器用加秘钥加密传输信息
防范：
  某种方法来确定他们是真正拿到了属于对方的公钥，

https缺点：
   使用https是有门槛，需要权威机构CA颁发证书，从证书选择，部署，都比较费力
   https性能消耗大于http，因为要加密。
   购买证书需要花销

它的过程大致来说是这样的：

客户端在第一次发送HTTPS请求的时候，会把 client_random、TSL版本号、加密套件列表发送给服务器
服务器在接收到之后确认TSL的版本号，同时发送 server_random、server_params、需要使用的加密套件、以及自己的证书给客户端
客户端在收到这些信息之后，首先是会对服务器的证书进行验证(也就是题目7)，若是验证成功则会传递一个 client_params 给服务器
与此同时客户端会通过ECDHE算法计算出一个pre_random，其中是传入了两个参数，一个是 client_params，还一个是 server_params。(也就是说：ECDHE(client_params, server_params) = per_random)
这时候客户端就同时拥有了 client_random、server_random、pre_random，它会将这三个参数通过一个伪随机函数计算得出最终的secret，这个secret就是它们后续通信所要用的对称密钥。
而在客户端生成完secret之后，会给服务器发送一个收尾消息，告诉服务器之后都要用对称加密，且对称加密的算法是用第一次约定好的。
服务器它在接收到刚刚传递过来的client_params之后，也会使用和客户端一样的方式生成secret，并且也会发送一个收尾消息给客户端。
当双方都收到收尾消息并验证成功之后，握手就结束了。后面开始用这个secret对称密钥加密报文进行传输。
   