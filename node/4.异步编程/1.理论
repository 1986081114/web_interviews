异步编程的难点; 
   异常处理： 在过去处理异常时，可以使用 try/catch进行异常捕捉， 但是在异步时，callback会被存放直到下一个事件循环
            才会执行，尝试对异步处理方法进行try/catch只能捕获当前事件循环内的异常， 对callback抛出的异常无能为力。
          node在处理异常时，通常将异常作为回调函数的第一个实参传回，如果为空值，说明没有异常。
    函数嵌套过深：对于node 事务中存在多个异步调用的场景比比皆是，比如读文件后循环写文件。

    阻塞代码： node中没有sleep()这样的线程沉睡功能，为了模拟实现沉睡通常：
        while(new Date() - start < 1000 ) { // Todo}
        但是这个代码会持续占用cpu进行判断，与真正的沉睡相去甚远，， 由于node单线程的原因， CPU资源会全用于这段代码服务
        导致其余请求得不到相应。遇到这样的需求使用settimeout会更好

    多线程编程： js通常是单一线程上执行的代码，如果服务器是多核CPU，单个node进程实质上是没有充分利用多核cpu的。

    异步转同步
异步编程的解决方案：
    事件发布/订阅模式
    promise/deferred
    流程控制库 