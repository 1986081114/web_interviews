单线程同步编程模型会阻塞I/O导致硬件资源得不到更优的使用， 多线程也因为编程中的死锁，状态同步等问题让人头疼
Node在两者直接给出了他的方案：
    利用单线程，远离多线程死锁，状态同步等问题，
    利用异步I/O，让单线程远离阻塞，以更好的利用CPU。

node的异步I/O:
  完整的异步I/O环节有事件循环，观察者和请求对象,I/O线程池。
    事件循环使得回调函数十分普遍，每次循环就是产看是否有事件待处理，如果有，取出事件及其回调函数执行，然后进入下个时间循环。
       如果没有事件处理，退出进程。
    事件循环过程中，判断是否有事件需要处理，必须要有观察者，判断事件是否需要处理就是向这些观察者询问是否有事件要处理。
        事件循环就是一个典型的生产者/消费者模式，异步I/O，网络请求，则是事件的生产者，为node提供不同的事件，这些事件被传递到对应的观察者哪里
        ，事件循环则从观察者哪里取出事件并处理。
    
    从js发起调用到内核执行完I/O操作的过度过程中，有一个中间产物-请求对象。
        node的核心模块调用C++的内建模块，创建一个请求对象，回调函数则被设置在这个对象的oncomplete_sym属性上，
        然后被推入线程池中等待执行以及I/O操作完毕后的回调处理，不管是否阻塞I/O，都不会影响后续执行。
    封装好对象并送入请求池，只是完成了I/O的第一部分，回调通知是第二部分。（P59）
       线程池的操作调用完毕后，会将结果存储在rep->result属性上，然后通知IOCP，告知当前对象操作已经完成，并归还线程。
       在事件循环中，会调用ICOP的相关方法检查线程池中是否有执行完的请求，如果存在将请求对象添加带I/O观察者的队列中，然后当做事件处理。
       I/O观察者取出回调函数执行就是 取出请求对象的result作为参数，取出oncomplete_sym作为方法，然后调用执行。以此达到调用回调函数的目的。


非I/O的异步api：
    setTimeout setInterval与浏览器的API是一致的，实现远离与异步I/O比较类似，只是不需要线程池，
      但是创建的一个定时器会被插入奥定时器观察者内部的一个红黑树内，每次循环过程从红黑树中迭代取出定时器对象
      如果超时，形成事件，立即执行回调函数。事件复杂度是O（lh(n)）
    process.nextTick：
       定时器因为需要红黑树，创建定时器对象和迭代等操作，浪费性能，多益需要更轻量的方法。每次调用nextTick方法只会将回电函数放在
       队列，在下一轮事件循环取出执行，时间复杂度是O(1);

    setImmediate():
        与process.nextTick类似，但是执行优先级更低，
        这是因为process.nextTick属于idle观察者，setImmediate属于check观察者，在每次循环检查中idle观察者高于I/O观察者，
        高于check观察者。实际上 process.nextTick回电函数保存在一个数组内，setImmediate保存在链表内，
        事件循环过程中，会将数组中的回调函数全部执行完在去执行链表中的一个回调函数，


