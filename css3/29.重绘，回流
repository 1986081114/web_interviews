回流（重排）： 布局或者几何属性更改成为节流
重绘：节点需要更改外观但是不影响布局，比如color

回流一定会发生重绘，但重绘不一定引发回流， 每次创建界面都会发生至少一次回流
相较于重排操作，重绘省去了布局和分层阶段，所以执行效率会比重排操作要高一些

display： none  回流，重绘；  visibility： hidden （重绘）

当页面布局和几何属性改变时就需要回流。下述情况会发生浏览器回流：
0：页面初始化，这是最大一次开销的重排。
1、添加或者删除可见的DOM元素；
2、元素位置改变；
3、元素尺寸改变——边距、填充、边框、宽度和高度
4、内容改变——比如文本改变或者图片大小改变而引起的计算值宽度和高度改变；
5、激活伪类，（：hover）
6、浏览器窗口尺寸改变——resize事件发生时；
7：查询某些属性：offsetWidth， offsetHeight， clientwidth， scrollwidth等

减少 ：
   浏览器： flush队列； 浏览器会有一个flush队列，储存触发的重绘与节流，等达到一定数量进行批处理。
   css:
        1.避免使用table布局，很小的波动，会造成整个table重新布局。（非要用就设置table-layout:auto/fixed，让table一行渲染）
        2.尽可能在Dom树末端改变class
        3.避免设置多层内联样式
        4.复杂动画应用到position absolute fixed
        5.避免使用css表达式 如cslc（）
        6.将频繁重绘或者回流的节点设置为图层，图层能够阻止该节点的渲染行为影响 别的节点，
         例如 will-change、video、iframe 等标签，浏览器会自动将该节点变 为图层
    js：
        1.避免频发操纵样式和DOM
        2.也可以先为元素设置display: none，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。
       
我们使用了CSS的transform来实现动画效果，这可以避开重排和重绘阶段，直接在非主线程上执行合成动画操作。这样的效率是最高的，
因为是在非主线程上合成，并没有占用主线程的资源，另外也避开了布局和绘制两个子阶段，所以相对于重绘和重排，
合成能大大提升绘制效率。

