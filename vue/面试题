1.vue事件绑定原理：
  原生事件通过addeventListener绑定给真实元素
  组件事件绑定通过vue自定义的$on实现

2.为什么v-if和v-for不建议一起使用：
   当v-for和v-if处于同一个节点， v-for优先级比v-if更高， 这意味着v-if将分别重复运行在每一个v-for循环中， 先循环在判断，性能浪费
    解决：
        在外层嵌套一个template（页面不会生成dom节点）， 在这一层先v-if判断在内部进行v-for
        如果出现条件在内部， 使用computed，对数据过滤

3.组建的data为什么是函数：
   组件可以复用，而且每个组件都有自己的状态，如果data是一个对象，在js里对象是引用关系，那么复用的组件共享一样的data，子组件data属性会相互影响，
   影响其他组件，而函数每次调用都会返回对象独立的拷贝，每一个组件的data是独立的，不会互相影响。
   本身的面向对象编程也是基于原型链和构造函数，应该会注意原型链上添加一般都是一个函数方法而不会去添加一个对象了

4.vue优化：
   v-if v-for不要连用，v-for优先级更高
   尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher
   在更多的情况下，使用v-if替代v-show
   spa页面采用keepalive缓存组件
   key保证唯一
   路由懒加载，
   防抖节流
   第三方模块按需导入
   图片懒加载
   长列表滚动可视化动态加载
   在更多替换条件下 v-if替换v-for
5.在 Vue 实例中编写生命周期 hook 或其他 option/properties 时，为什么不使用箭头函数 ？

   箭头函数自已没有定义 this 上下文中。当你在 Vue 程序中使用箭头函数 ( => ) 时，this 关键字病不会绑定到 Vue 实例，
   因此会引发错误。所以强烈建议改用标准函数声明。

6.sr：
      服务端渲染（ssr）：就是将组件或者页面在服务端完成了标签渲染成html片段。，服务端形成的html片段直接返回给客户端这个过程就叫做服务端渲染。
      优点： 
         更好的seo：因为spa页面的内容同股票ajax获取，而搜索引擎工具并不会等待ajax异步完成在抓取页面内容， 所以在spa中抓取不到ajax获取的内容
                     而ssr是直接由服务端返回渲染好的页面（包含数据）， 所以搜索引擎工具可以抓取的到
         首屏加载更快： spa会等待所有的vue编译后的js都文件下载完成，才开始进行页面的渲染， 文件下载需要事件，所以首屏需要等待一段时间。
                     ssr直接由服务器渲染好页面返回， 无需等待下载js文件再去渲染， 
      缺点：
         各部分定义的开发限制，服务端渲染只支持before和created两个钩子函数， 限制了开发， 服务端渲染的引用程序需要处于node.js 运行环境
                     spa可以不出在任何静态文件服务器上

         更多的服务器负载： 在服务器渲染整个应用程序， 显然会占用大量cpu资源，增加服务器压力


7.子组件为什么不能修改父组件传递的prop，怎么理解vue单向数据流:
  这是为了防止意外改变父组件状态， 使得应用的数据流变得难以理解， 
   组件是可复用的，假设该子组件被复用了n次，当某一个组件意外地更改了其接受到的props数据 ----> 
    意味着，同时更改了父组件中相对应的属性值 ----> 意外地更改其它(n-1)个子组件中的 props数据，引起混乱

8.vue不能检测数组的那些变动， vue怎没用vm,$set()解决对象新增属性不能响应问题？

    官方解释是， 由于js限制， vue不能检测一下数组的变动
        当你利用索引直接设置一个项时，例如： vm.items[indexOfItem] = newValue
         当你修改数组的长度时，例如： vm.items.length = newLength 
               // 法一：Vue.set
         Vue.set(vm.items, indexOfItem, newValue)
         // 法二：Array.prototype.splice
         vm.items.splice(indexOfItem, 1, newValue)
         修改长度： vm.items.splice(newLength)
 
  vue不能检测直接利用索引设置数据项，修改数组的长度。
9.vue2.x中如何监测数组变化？

  但是也请注意并非所有的数组方法都重新写了一遍，只有push，pop，shift，unshift，splice, sort，reverse这七个。至于为什么不用Object.defineProperty去监听数组中已存在的元素变化。
   作者尤雨溪的考虑是因为性能原因，给每一个数组元素绑定上监听，实际消耗很大，而受益不大
使用了函数劫持的方式，重写了数组的方法，Vue将data中的数组进行了原型链重写，指向了自己定义的数组原型方法，
当调用数组api时，可以通知依赖更新。如果数组中包含着引用类型，会对数组中的引用类型再次递归遍历进行监控。这样就实现了监测数组变化。

10.对于即将到来的 vue3.0 特性你有什么了解的吗？

监测机制的改变

3.0 对于即将到来的 vue3.0 特性你有什么了解的吗？

  将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：
   只能监测属性，不能监测对象

   检测属性的添加和删除；检测数组索引和长度的变更；支持 Map、Set、WeakMap 和 WeakSet。
   模板

   模板方面没有大的变更，只改了作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。
   对象式的组件声明方式

   vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易
   其它方面的更改

   支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。基于 tree shaking 优化，提供了更多的内置功能。


11.数据冻结：
    
 vue通过Object.defineProperty对数据劫持， 来实现视图响应数据的变化， 然而有时候组件就是单纯的数据展示，不会有变化，禁止vue的数据劫持
   created（）{
      user = Object.freeze(data)
   }



